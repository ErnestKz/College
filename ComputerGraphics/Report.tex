% Created 2021-01-05 Tue 22:36
% Intended LaTeX compiler: pdflatex
\documentclass[11pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{grffile}
\usepackage{longtable}
\usepackage{wrapfig}
\usepackage{rotating}
\usepackage[normalem]{ulem}
\usepackage{amsmath}
\usepackage{textcomp}
\usepackage{amssymb}
\usepackage{capt-of}
\usepackage{hyperref}
\date{\today}
\title{}
\hypersetup{
 pdfauthor={},
 pdftitle={},
 pdfkeywords={},
 pdfsubject={},
 pdfcreator={Emacs 27.1 (Org mode 9.3)}, 
 pdflang={English}}
\begin{document}


\section*{Computer Graphics Report}
\label{sec:org1c7b823}
\subsubsection*{Ernests Kuznecovs - 17332791}
\label{sec:org1e5f318}
\subsubsection*{05/01/2021}
\label{sec:org794180e}
\begin{itemize}
\item Demo link: \url{https://www.youtube.com/watch?v=4ZjR1sLL12Q}
\end{itemize}

\subsection*{Midterm Summary}
\label{sec:org552150f}
In the miderm, the features that had been implemented were:   
\begin{itemize}
\item Camera Looking
\item Camera Movement
\item Model Loading
\item Texture Loading (via assimp)
\item Mesh Hierarcy
\end{itemize}
Many of the features above derived from LearnOpenGL.com as a resource to learn from.

\subsection*{Final Project Summary}
\label{sec:org9dc0f5c}
The additional features that had been implemented since then are:
\begin{itemize}
\item Crowd of spiders
\item Multiple light sources
\item A controllable dynamic light
\item Texture on the plane
\item Pause/Play feature on the crowd
\item Ability to show hitbox of each of the spiders
\item Abilty to aim at hitbox and detect intersection with the camera view direction
\item Ability to select the spider that is being aimed at
\item Ability to move selected spider around
\end{itemize}
The rest of the report will describe these features in additional detail.

\subsection*{Crowd of Spiders}
\label{sec:orgf2e8088}
The crowd is represented as a vector of Model objects.   
Model objects store mesh data, hierarchy structure, and a drawing function.   
Models also store their position and rotation in the world as vec2 and flaot that is then used
to create the translation matrices (done outside the Model class for quick prototyping)   
\subsubsection*{Using world positions.}
\label{sec:orgf040116}
The Model class provides functions to update these world positions:
\begin{verbatim}
void move_forward(float distance) {
  float x = cos(forward_direction_rad) * distance;
  float z = sin(forward_direction_rad) * distance;
  pos.x = pos.x + x;
  pos.y = pos.y + z;
}

void rotate(float rad) {
  forward_direction_rad += rad;
}
\end{verbatim}
Using the positions to calculate transformation matrices:
\begin{verbatim}
auto& spider = crowd[i];
auto translation = glm::translate(glm::mat4(1.0f),
		   glm::vec3(-spider.pos.x, 0, -spider.pos.y));
model = glm::rotate(translation,
		    -spider.forward_direction_rad,
		    glm::vec3(0.0f, 1.0f, 0.0f));
\end{verbatim}
\subsubsection*{Managing crowd datastructure}
\label{sec:org5eb0c3d}
The crowd is initialised with the same spider model but at different starting positions.   
In the drawing loop, there is one function that animates the spiders legs via the hierarchy and updates its world 
position, and another function that applies the transformations and draws them.   

e.g animations and world position updates
\begin{verbatim}
void crowd_iteration(vector<Model>& crowd, Shader& spider_shader) {
  for (int i = 0; i < crowd.size(); i++){
    auto& spider_model = crowd[i];
    float rotation = i % 2 == 0 ? -0.01 : 0.01;
    spider_model.rotate(rotation * (i + 1));
    spider_model.move_forward(0.055 * i + 0.01);
    animate_spider(spider_model.hierarchy);
  }
}
\end{verbatim}

\subsection*{Dynamic Light Source}
\label{sec:orgffe19ad}
The most obvious light source that is seen is the yellowish ball that can move around.   
The ball itself is a sphere that is loaded into the application. The model and the light source
share the same coordinate ( the ball is translated to the position in the world to where the light 
source is ).   

The world space posisition of the light is controlled with the keyboard i,j,k,l.   

The position of the light, and camera position is passed to the fragment shader in order to calculate the light
that changes position and where the camera changes.   
e.g calculating power of specular light:
\begin{verbatim}
vec3 light_direction = normalize(light_position - vertex_world);
vec3 view_direction = normalize(vertex_world - view_position);                      
vec3 reflection_direction = normalize(reflect(light_direction, tnorm));            
float specular_dot_product = max(dot(view_direction, reflection_direction), 0.0);  
\end{verbatim}

\subsection*{Multple Light Sources}
\label{sec:org50c5859}
The light sources that are implemented are just ambient + diffuse + specular.   
The first light source was the dynamic one, but the second one is just a blue point light, 2 units 
above the origin emmiting blue light.   

The light is simply implemented in the shaders themselves for the reason of protyping, but for a biffer project I
would pass the multiple light sources as an array of light source parameters for the shader to apply.
\subsection*{Texture on the Plane}
\label{sec:org33b09bb}
The texture on the ground is a png of a stone wall with the GL\textsubscript{REPEAT} option.
The texutre coordinates were picked by hand and an indexed array was used to specify which order 
to apply the texture coordinates for the shaders.   

\subsection*{Pause/Play Feature on the Crowd}
\label{sec:org4f49a5d}
This feature was implemented as it would be useful to have in order to debug future features that would be added, such 
as boids.   

There is a boolean switch in the global scope of the application. A key is bound to toggle the value of the boolean.   

The boolean is used in the drawing loop to decide whether or not skip a crowd iteration.
\begin{verbatim}
if (next_state){
  crowd_iteration(crowd, spider_shader);
}
draw_crowd(crowd, spider_shader,camera, sphere_shader);
\end{verbatim}
Just having the crowd\textsubscript{iteration} in the boolean allows for camera movements and any other additional control features
to still work.

\subsection*{Show Hitbox}
\label{sec:org487720b}
This is just a unit sphere drawn in wireframe.   

The spiders world position is used to determine where to translate the sphere for rendering.   

A boolean switch exists that determines if the spheres should be drawn.
\subsection*{Aim at Hitbox}
\label{sec:org56948be}
This feature uses some of the mathematic of ray tracing.  
The camera position, direction, and position of the sphere are used to calculate if there is an intersection.
\begin{verbatim}
bool camera_intersects_sphere(glm::vec3 cam_pos, glm::vec3 sphere_pos, 
						 glm::vec3 cam_direction) {
  float b = 2 * cam_direction.x * (cam_pos.x - sphere_pos.x) +
    2 * cam_direction.z * (cam_pos.z - sphere_pos.z) +
    2 * cam_direction.y * (cam_pos.y - sphere_pos.y);
  float c = (cam_pos.x - sphere_pos.x) * (cam_pos.x - sphere_pos.x) +
    (cam_pos.y - sphere_pos.y) * (cam_pos.y - sphere_pos.y) +
    (cam_pos.z - sphere_pos.z) * (cam_pos.z - sphere_pos.z) - 1;

  float d = b * b - 4 * c;
  return d >= 0;
}
\end{verbatim}
\subsection*{Select Spider}
\label{sec:org3b2ba24}
A key can be pressed to lock in the aimed-at spider. This changes the colour of the hitbox to red to show 
that its locked.

All of this functionality is controlled with 2 variables, one for keeping which spider is aimed at, and 
one for determining if the lock has been activated.
\begin{verbatim}
if (intersected && !aiming_lock) 
  aiming_at = i;
if (aiming_at == i)
  sphere_shader.setVec3("ball_colour", glm::vec3(0.3, 0.8, 0.3));
if (aiming_at == i && aiming_lock)
  sphere_shader.setVec3("ball_colour", glm::vec3(0.9, 0.2, 0.0));

\end{verbatim}
\subsection*{Move Spider}
\label{sec:org9789936}
Once a spider is selected, it can be moved.  

Within the key processing, the selected spiders world positions is incremented/decremented.
\begin{verbatim}
if (glfwGetKey(window, GLFW_KEY_E) == GLFW_PRESS && aiming_lock == true) 
  crowd[aiming_at].move_forward(-0.1);
if (glfwGetKey(window, GLFW_KEY_U) == GLFW_PRESS && aiming_lock == true) 
  crowd[aiming_at].rotate(0.1);
\end{verbatim}
\end{document}
